# Go 文件操作

## FileInfo文件信息

文件信息包括**文件名、文件大小、修改权限、修改时间等**

```go
package main

import (
	"fmt"
	"os"
)

func printMessage(filepath string){
	fileinfo,err := os.Stat(filepath)
	if err != nil{
		fmt.Println("err")
	}
	fmt.Printf("文件类型：%T \n",fileinfo)
	fmt.Printf("文件名：%v \n",fileinfo.Name())
	fmt.Printf("是否为目录：%v \n",fileinfo.IsDir())
	fmt.Printf("文件大小：%v \n",fileinfo.Size())
	fmt.Printf("文件权限：%v \n",fileinfo.Mode())
	fmt.Printf("最近修改时间：%v \n",fileinfo.ModTime())
}

func main() {
	filepath := "./main.go"
	printMessage(filepath)
}
/*
返回： #############################################################
文件类型：*os.fileStat
文件名：main.go
是否为文件：false
文件大小：550
文件权限：-rw-rw-rw-
最近修改时间：2021-01-08 17:01:14.8301072 +0800 CST
*/
```

## 文件路劲

```go
import (
	"path/filepath"
)
```

`filepath.IsAbs() 判断是否为绝对路劲返回true/false`

`filepath.Abs()`获取据对路劲

```
fmt.Println(filepath.Abs(".")) // 当前据对路劲
```

`filepath.Rel()`获取相对路劲

// 获取 targpath 相对于 basepath 的路径。
// 要求 targpath 和 basepath 必须“都是相对路径”或“都是绝对路径”。

`filepath.Join()`路劲拼接

```go
func main() {
	filepath1 := "./main.go"
	filepath2 := `C:\Users\Administrator\go\src\awesomeProject\包\main.go`
	fmt.Println(filepath.IsAbs(filepath1))  // false
	fmt.Println(filepath.Abs(filepath2))    // \main.go <nil>
	fmt.Println(filepath.Join("/root/myfile",filepath1)) //\root\myfile\main.go windows为反斜线
}
```

```go
// 获取 targpath 相对于 basepath 的路径。
// 要求 targpath 和 basepath 必须“都是相对路径”或“都是绝对路径”。
Rel(basepath, targpath string) (string, error)

func main() {
	// 都是绝对路径
	s, err := filepath.Rel(`/a/b/c`, `/a/b/c/d/e`)
	fmt.Println(s, err) // d/e <nil>

	// 都是相对路径
	s, err = filepath.Rel(`a/b/c`, `a/b/c/d/e`)
	fmt.Println(s, err) // d/e <nil>

	// 一个绝对一个相对
	s, err = filepath.Rel(`/a/b/c`, `a/b/c/d/e`)
	fmt.Println(s, err)
	//  Rel: can't make a/b/c/d/e relative to /a/b/c

	// 一个相对一个绝对
	s, err = filepath.Rel(`a/b/c`, `/a/b/c/d/e`)
	fmt.Println(s, err)
	//  Rel: can't make /a/b/c/d/e relative to a/b/c

	// 从 `a/b/c` 进入 `a/b/d/e`，只需要进入 `../d/e` 即可
	s, err = filepath.Rel(`a/b/c`, `a/b/d/e`)
	fmt.Println(s, err) // ../d/e <nil>
}
```

## 创建目录

```
os.Mkdir()    // 创建一层目录
os.MkdirAll() // 创建多层目录
```

```go
os.Mkdir("path_a",0755)         // ./path_a  ?权限windows不生效
os.MkdirAll(`path1\path2`,0755)  // ./path1/path2
```

## 删除文件

`os.Remove()`

`os.RemoveAll()`

```
	// 删除当前目录下 path_a
	err := os.Remove(`path_a`)
	if err != nil{
		fmt.Println(err)
		return
	}
	fmt.Println("path_a 删除成功")
	// 删除当前目录下path1及其子目录
	err1 := os.RemoveAll(`./path1`)
	if err1 != nil{
		fmt.Println(err)
		return
	}
	fmt.Println("path1及子目录 删除成功")
```



## 打开关闭文件

 `os.Open()`函数能够打开一个文件，返回一个`*File`和一个`err`。对得到的文件实例调用`close()`方法能够关闭文件。 

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	// 只读方式打开当前目录的main.go文件
	file ,err := os.Open("./main.go")
	if err != nil{
		fmt.Println("filed",err)
		return
	}
	// 关闭文件
	defer file.Close()
}
```

## 复制文件

`fopyFile()`





## 读取文件

Read方法定义如下：

```go
func (f *File) Read(b []byte) (n int, err error)
```

 它接收一个字节切片，返回读取的字节数和可能的具体错误，读到文件末尾时会返回`0`和`io.EOF`。 举个例子： 























