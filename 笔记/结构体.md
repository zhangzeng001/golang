

# 类型别名和自定义类型

* 自定义类型

   在Go语言中有一些基本的数据类型，如`string`、`整型`、`浮点型`、`布尔`等数据类型， Go语言中可以使用`type`关键字来定义自定义类型。
   
   `type MyInt int`
   
   通过`type`关键字的定义，`MyInt`就是一种新的类型，它具有`int`的特性。 
   
   ```go
   type myInt int
   
   func main() {
   	var v1 myInt = 110
   	fmt.Printf("%T", v1) //main.myInt
   }
   ```
   
    表示main包下定义的`myInt`类型 
   
* 类型别名

   类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。 

   `type TypeAlias = Type`

    我们之前见过的`rune`和`byte`就是类型别名，他们的定义如下： 

   ```go
   type byte = uint8
   type rune = int32
   ```

   ```go
   type myInt = int
   
   func main() {
   	var v2 myInt = 32
   	fmt.Printf("%T", v2) //int
   }
   ```

    v2的类型是`int`。`MyInt`类型只会在代码中存在，编译完成时并不会有`MyInt`类型。 



# 结构体

Go语言中的基础数据类型可以表示一些事物的基本属性，但是当我们想表达一个事物的全部或部分属性时，这时候再用单一的基本数据类型明显就无法满足需求了，Go语言提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名称`struct`。 也就是我们可以通过`struct`来定义自己的类型了。

Go语言中通过`struct`来实现面向对象。

## 结构体定义

使用`type`和`struct`关键字来定义结构体，具体代码格式如下： 

```go
type Name struct {
	Field1 Type2
	Field2 Type2
	....
}
```

其中：

- 类型名：标识自定义结构体的名称，在同一个包内不能重复。
- 字段名：表示结构体字段名。结构体中的字段名必须唯一。
- 字段类型：表示结构体字段的具体类型。

```go
type user struct {
	name              string
	age               int8
	gender            string
	score, numberuser int16 // 相同类型可以写到一行
	hobby             []int // 类型也可以是切片等
}
```



## 结构体实例化

只有当结构体实例化时，才会真正地分配内存。也就是必须实例化后才能使用结构体的字段。

结构体本身也是一种类型，我们可以像声明内置类型一样使用`var`关键字声明结构体类型。

`var 结构体实例  结构体类型`

* 基本实例化

  ```go
  type nickname struct {
  	name              string
  	age               int8
  	gender            string
  	score, numberuser int16 // 相同类型可以写到一行
  	hobby             []int // 类型也可以是切片等
  }
  
  func main() {
  	var xiaozhang nickname
  	xiaozhang.name = "zhang3"
  	xiaozhang.age = 18
  	xiaozhang.gender = "male"
  
  	fmt.Println(xiaozhang) //{zhang3 18 male 0 0 []}
  }
  ```

  ```go
  // 嵌套map类型
  type hero struct {
  	name       string
  	activation bool
  	attribute  map[string]int
  }
  
  func main() {
  	var jax hero
  	jax.name = "jax"
  	jax.activation = true
  	jax.attribute = map[string]int{
  		"HP": 800,
  		"MP": 800,
  	}
  	fmt.Println(jax) // {jax true map[HP:800 MP:800]}
  }
  ```

  

* 匿名结构体

  <font color=FF0000 >在定义一些临时数据结构等场景下还可以使用匿名结构体。 </font>

  ```go
  func main() {
  	var user struct {
  		name string
  		age  int
  	}
  	user.name = "zhang"
  	user.age = 18
  	fmt.Println(user) //{zhang 18}
  }
  ```

  

* 创建指针类型结构体

  我们还可以通过使用`new`关键字对结构体进行实例化，得到的是结构体的地址。 格式如下： 

  ```go
  type hero struct {
  	name       string
  	activation bool
  	attribute  map[string]int
  }
  
  func main() {
  	var s2 = new(hero)
  	fmt.Printf("%T\n", s2)  //*main.hero *Type表示类型指针*main.hero
      //&main.hero{name:"", activation:false, attribute:map[string]int(nil)}
  	fmt.Printf("%#v\n", s2) 
      v1 := 1
  	fmt.Printf("%p\n", &v1) //0x110120a0
  }
  ```

  从打印的结果中我们可以看出s2`是一个结构体指针。 

  Go语言中支持对结构体指针直接使用`.`来访问结构体的成员。

  ```go
  type hero struct {
  	name       string
  	activation bool
  	attribute  map[string]int
  }
  
  func main() {
  	var s2 = new(hero)
  	s2.name = "KAS"
  	s2.activation = true
  	s2.attribute = map[string]int{
  		"HP": 10000,
  		"mp": 99999,
  	}
  	// &{KAS true map[HP:10000 mp:99999]}
  	fmt.Println(*s2)
  	// {KAS true map[HP:10000 mp:99999]}
  	fmt.Println(*s2)
  }
  ```



* 取结构体的地址实例化

  使用`&`对结构体进行取地址操作相当于对该结构体类型进行了一次`new`实例化操作。 

  ```go
  type hero struct {
  	name       string
  	activation bool
  	attribute  map[string]int
  }
  
  func main() {
  	var s3 = &hero{}
  	fmt.Printf("%T\n", s3) //*main.hero
  	// &main.hero{name:"", activation:false, attribute:map[string]int(nil)}
  	fmt.Printf("%#v", s3)
  }
  ```

  

## 结构体初始化

 没有初始化的结构体，其成员变量都是对应其类型的零值。 

```go
type nickname struct {
	name              string
	age               int8
	gender            string
	score, numberuser int16 // 相同类型可以写到一行
	hobby             []int // 类型也可以是切片等
}

func main() {
	var s4 nickname
	fmt.Println(s4) //{ 0  0 0 []}
}
```

* 使用键值对初始化

  使用键值对对结构体进行初始化时，键对应结构体的字段，值对应该字段的初始值。 

  ```go
  type nickname struct {
  	name              string
  	age               int8
  	gender            string
  	score, numberuser int16    // 相同类型可以写到一行
  	hobby             []string // 类型也可以是切片等
  }
  
  func main() {
  	s5 := nickname{
  		name:       "li",
  		age:        18,
  		gender:     "female",
  		score:      100,
  		numberuser: 10000,
  		hobby:      []string{"看书", "听音乐"},
  	}
  	fmt.Println(s5) //{li 18 female 100 10000 [看书 听音乐]}
  }
  ```



* 也可以对结构体指针进行键值初始化

  ```go
  type nickname struct {
  	name              string
  	age               int8
  	gender            string
  	score, numberuser int16    // 相同类型可以写到一行
  	hobby             []string // 类型也可以是切片等
  }
  
  func main() {
  	s6 := &nickname{
  		name:       "li",
  		age:        18,
  		gender:     "female",
  		hobby:      []string{"看书", "听音乐"},
  	}
  	fmt.Println(s6) //&{li 18 female 0 0 [看书 听音乐]}
  	fmt.Printf("%T", s6) //*main.nickname
  }
  ```



* 初始化根据顺序直接写值

  ```go
  type nickname struct {
  	name              string
  	age               int8
  	gender            string
  	score, numberuser int16    // 相同类型可以写到一行
  	hobby             []string // 类型也可以是切片等
  }
  
  func main() {
  	s7 := &nickname{
  		"wang",
  		12,
  		"female",
  		80,
  		10001,
  		[]string{"chi", "shui"},
  	}
  	fmt.Println(s7) //&{wang 12 female 80 10001 [chi shui]}
  }
  ```

  使用这种格式初始化时，需要注意：

  1. 必须初始化结构体的所有字段。
  2. 初始值的填充顺序必须与字段在结构体中的声明顺序一致。
  3. 该方式不能和键值初始化方式混用。

  

## 结构体内存布局

 结构体占用一块连续的内存。 

```go
type test struct {
	a int8
	b int8
	c int8
	d int8
}
n := test{
	1, 2, 3, 4,
}
fmt.Printf("n.a %p\n", &n.a)
fmt.Printf("n.b %p\n", &n.b)
fmt.Printf("n.c %p\n", &n.c)
fmt.Printf("n.d %p\n", &n.d)

// 输出
n.a 0xc0000a0060
n.b 0xc0000a0061
n.c 0xc0000a0062
n.d 0xc0000a0063
```

 Go语言中的内存对齐推荐阅读:[在 Go 中恰到好处的内存对齐](https://segmentfault.com/a/1190000017527311?utm_campaign=studygolang.com&utm_medium=studygolang.com&utm_source=studygolang.com) 

## 空结构体

 空结构体是不占用空间的。 

```go
var v struct{}
fmt.Println(unsafe.Sizeof(v))  // 0
```



## 构造函数

 Go语言的结构体没有构造函数，我们可以自己实现。 例如，下方的代码就实现了一个`person`的构造函数。 因为`struct`是值类型，如果结构体比较复杂的话，值拷贝性能开销会比较大，所以该构造函数返回的是结构体指针类型。 

```go
type nickname struct {
	name   string
	age    int8
	gender string
	hobby  []string // 类型也可以是切片等
}

func newNickname(name string, age int8, gender string, hobby []string) *nickname {
	return &nickname{
		name:   name,
		age:    age,
		gender: gender,
		hobby:  hobby,
	}
}

func main() {
	ss1 := newNickname("zhang3", 13, "female", []string{
		"xxxx",
		"wwww",
	})
	fmt.Println(ss1)  //&{zhang3 13 female [xxxx wwww]}
	fmt.Println(*ss1) //{zhang3 13 female [xxxx wwww]}
}
```

## 方法和接收者

 Go语言中的`方法（Method）`是一种作用于特定类型变量的函数。这种特定类型变量叫做`接收者（Receiver）`。接收者的概念就类似于其他语言中的`this`或者 `self`。 

```go
func (接收者变量 接收者类型) 方法名(参数列表) (返回参数) {
    函数体
}
```

其中，

- 接收者变量：接收者中的参数变量名在命名时，官方建议使用接收者类型名称首字母的小写，而不是`self`、`this`之类的命名。例如，`Person`类型的接收者变量应该命名为 `p`，`Connector`类型的接收者变量应该命名为`c`等。
- 接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。
- 方法名、参数列表、返回参数：具体格式与函数定义相同。











