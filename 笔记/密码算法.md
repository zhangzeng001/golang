# hash与加密解密的区别

[go语言开发实战](287)

`Hash`是将目标文本转换成具有相同长度的、不可逆的杂凑字符串

`加密(Encrypt)`是将目标文本转换成鱼油不通长度的、可逆的密文

https://www.cnblogs.com/xumaojun/p/8541638.html

![1614142153657](密码算法.assets\1614142153657.png)

## 使用简单的一次哈希Hash方法进行数据保护

![1614142241475](密码算法.assets\1614142241475.png)

# encoding/hex

```go
func main() {
	// 预定义字符串切片
	arr := []byte{'1','0','0','0','p','h','o','n','e'}
	fmt.Println(string(arr)) // 1000phone

	// 将字节数组转换成十六进制字符串
	s1 := hex.EncodeToString(arr)
	fmt.Println(s1)  // 3130303070686f6e65

	// 将十六进制字符串转换成字节数组
	s2,_ := hex.DecodeString(s1)
	fmt.Println(s2)
	fmt.Printf("%x\n",s2)

	// 十六进制大段小段颠倒
	s3 ,_ := hex.DecodeString(s1)
	for i,j := 0 ,len(s3)-1; i<j; i,j=i+1,j-1{
		s3[i],s3[j] = s3[j],s3[i]
	}
	fmt.Printf("%x\n",s3)  // 656e6f687030303031

	// 字节数组大小端颠倒
	for i,j := 0 ,len(arr)-1; i<j; i,j=i+1,j-1{
		arr[i],arr[j] = arr[j],arr[i]
	}
	fmt.Printf("%x\n",arr)
}
```



# hash函数

linux下`md5sum` 和 `md5`的区别

我们默认算出的md5是不包含\0或者换行的，而md5sum包含。

建议大家试一下 echo -n abcd | md5sum 忽略换行

## hash加密算法类

```go
package main

import (
	"crypto/md5"
	"crypto/sha1"
	"crypto/sha256"
	"crypto/sha512"
	"encoding/hex"
	"fmt"
	"hash"
)
// HASH ...多种加密
func HASH(text string,hastType string,isHex bool) string{
	/*
	text:      加密字符串
	hastType： 加密类型
	isHex：    是否编码成十六进制字符串再加密
	*/
	// 定义 Hash 对象
	var hashInstance hash.Hash
	// 判断输入加密方法
	switch hastType {
	case "md5":
		hashInstance = md5.New()
	case "sha1":
		hashInstance = sha1.New()
	case "sha256":
		hashInstance = sha256.New()
	case "sha512":
		hashInstance = sha512.New()
	}
	// 是否编码后加密
	if isHex{
		arr,_ := hex.DecodeString(text)
		hashInstance.Write(arr)
	}else {
		hashInstance.Write([]byte(text))
	}
	// Sum appends the current hash to b and returns the resulting slice.
	// It does not change the underlying hash state.
	cipherBytes := hashInstance.Sum(nil)
	//fmt.Println(hex.EncodeToString(cipherBytes))  // a0e56e8856bb65c0735e2a81d823e1f1
	return fmt.Sprintf("%x",cipherBytes)   // a0e56e8856bb65c0735e2a81d823e1f1
}

// SHA256Double sha256多重加密演示
func SHA256Double(text string,isHex bool)string{
	hashInstance := sha256.New()
	if isHex{
		arr,_ := hex.DecodeString(text)
		hashInstance.Write(arr)
	}else {
		hashInstance.Write([]byte(text))
	}
	cipherBytes := hashInstance.Sum(nil)
	hashInstance.Reset()
	hashInstance.Write(cipherBytes)
	cipherBytes = hashInstance.Sum(nil)

	// 返回加密字字节通过fmt.Sprintf("%x",cipherBytes)转换
	//return cipherBytes
	return fmt.Sprintf("%x",cipherBytes)
}


func main() {
	// 多种加密方式
	resMd5 := HASH("test123","md5",false)
	resSh1 := HASH("test123","sha1",false)
	resSh256 := HASH("test123","sha256",false)
	fmt.Println(resMd5)    // cc03e747a6afbbcbf8be7668acfebee5
	fmt.Println(resSh1)    // 7288edd0fc3ffcbe93a0cf06e3568e28521687bc
	fmt.Println(resSh256)  // ecd71870d1963316a97e3ac3408c9835ad8cf0f3c1bc703527c30265534f75ae

	// SHA256双重加密
	resSHA256Double := SHA256Double("test123",false)
	fmt.Println(resSHA256Double)  // 6db8da2e476f56550406cbf65c8d35edd6070e420675246db8d7c9650cdc2e48
}
```



# 对称加密算法

https://baike.baidu.com/item/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/2152944?fr=aladdin

https://www.cnblogs.com/kumata/p/10519548.html

`对称加密`也叫私钥加密算法，指加密和解密使用相同密钥的加密算法

**有点：** 计量小、加密速度快，加密效率高

**不足：**参与放需要提前持有密钥，密钥一旦泄露则破坏系统安全性

## DES加密解密

![1614142616641](密码算法.assets\1614142616641.png)

**加密**

```go
package main

import (
	"bytes"
	"crypto/cipher"
	"crypto/des"
	"fmt"
	"log"
)

// DesEncrypt DES 加密字节数组，返回字节数组
func DesEncrypt(originalBytes,key []byte) ([]byte,error) {
	block, err := des.NewCipher(key)
	if err != nil{
		return nil, err
	}
	// 尾部填充 BlockSize()返回密码块大小
	originalBytes = PKCS5Padding(originalBytes,block.BlockSize())
	blockMode := cipher.NewCBCEncrypter(block,key)
	cipherArr := make([]byte,len(originalBytes))
	blockMode.CryptBlocks(cipherArr,originalBytes)
	return cipherArr,nil
}

// 解密字节数组
func DesDecrypt(cripherBytes,key []byte)([]byte,error){
	block,err := des.NewCipher(key)
	if err != nil {
		return nil, err
	}
	blockMode := cipher.NewCBCDecrypter(block,key)
	originalText := make([]byte,len(cripherBytes))
	blockMode.CryptBlocks(originalText,cripherBytes)
	originalText = PKCS5UnPadding(originalText)
	return originalText,nil
}

// PKCS5Padding 尾部填充，使用PKCS5填充
func PKCS5Padding(ciphertext []byte,blockSize int)[]byte{
	padding := blockSize - len(ciphertext)%blockSize
	padtext := bytes.Repeat([]byte{byte(padding)},padding)
	return append(ciphertext,padtext...)
}

func PKCS5UnPadding(origData []byte)[]byte{
	length := len(origData)
	// 去掉最后一个字节 unpadding次
	unpadding := int(origData[length-1])
	return origData[:(length - unpadding)]
}

func main() {
	// 加密
	// 密钥只能为8个字节
	key := []byte("sfd*&sD2")
	arr := "password@123"
	res,err := DesEncrypt([]byte(arr),key)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("加密字符串：",arr)
	fmt.Println("加密密钥：",string(key))
	//fmt.Println(res)  // [232 185 4 221 242 240 102 150 204 74 106 249 98 208 137 149]
	fmt.Printf("加密密文： %x\n",res)  // e8b904ddf2f06696cc4a6af962d08995

	// 解密
	desDecrypt,err := DesDecrypt(res,key)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("解密字符串：",string(desDecrypt))
}
```

返回：

```ini
加密字符串： password@123
加密密钥： sfd*&sD2
加密密文： e8b904ddf2f06696cc4a6af962d08995
解密字符串： password@123
```



## 3DES







## AES





















