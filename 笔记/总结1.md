# 字符串

* 字符串遍历 `byte`,`rune`

   rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。 

  ```go
  func main() {
  	s := "hello中文"
  	// for 遍历
  	for _, v := range s {
  		fmt.Printf("%c", v)
  	}
  
  	// rune byte 返回切片
  	str := []rune(s)
  	println(string(str))
  	// 修改字符，字符用单引号
  	str[5] = '语'
  	println(string(str))
  }
  ```

  

# 变量

## 变量

* 变量申明

  * 标准申明

    `var 变量 变量类型`

    ```go
    var v1 int
    var v2 string
    var v3 bool
    ```

  * 批量申明

    ```go
    var (
    	v1 int
        v2 string = "abc"
    )
    ```

  * 函数内申明

    ```go
    v1 := 1
    v2 := "abc"
    ```

    

* 变量初始化

  * 已申明变量

    `变量 = 值` 

    ```go
    v1 = 123
    v2 = "abc"
    v3 = true
    ```

  * 申明时初始化值

    ```go
    var v1 int = 1
    var v2 string = abc
    ```



## 常量

* 常量声明时必须赋值

  ` const 变量名 类型 = 值`

  ```go
  const c1 int = 1
  const c2 bool = true
  ```

* 批量申明

  ```go
  const (
  	c3 = 100 //100
  	c4       //100
  	c5 = 101 //101
      c6       //101
  )
  ```



### iota

`iota` 是go语言的常量计数器，只能在常量的表达式中使用。 

`iota`在const关键字出现记录当前第几行，const中每新增一行常量申明`iota`计数+1。使用iota能简化定义，在定义枚举时很有用。

```go
onst (
    c1 = 1    // 1
    c2 = iota // 1
    c3 = 100  // 100
    c4 = iota // 3
    c5        // 4
)
```





# 数组

* 数组定义

  `var 数组名 [容量]类型`

  ```go
  // 数组定义
  var a1 [3]int
  // 数组定义并初始化
  var a2 = [3]string{"a", "b", "c"}
  var a3 = [...]bool{true, false}
  // 数组初始化
  a1 = [3]int{1, 2, 3}
  fmt.Println(a1, a2, a3)
  // 根据索引位置赋值初始化
  a4 := [...]int{0: 1, 3: 8} //[1 0 0 8]中间的使用默认值0补齐
  fmt.Println(a4)
  ```

* 数组遍历

  ```go
  a := [...]string{"a", "b", "c"}
  for i := 0; i < len(a); i++ {
      fmt.Println(a[i])
  }
  for _, v := range a {
      fmt.Println(v)
  }
  ```

* 多维数组定义

  ```go
  var a1 = [...][3]int{
      {1, 2, 3},
      {4, 5, 6},
  }
  fmt.Println(a1)
  ```

* 多维数组遍历

  ```go
  var a1 = [...][3]int{
      {1, 2, 3},
      {4, 5, 6},
  }
  // fmt.Println(a1)
  for i := 0; i < len(a1); i++ {
      // fmt.Println(a1[i])
      for j := 0; j < len(a1[i]); j++ {
          fmt.Println(a1[i][j])
      }
  }
  
  for _, v := range a1 {
      for _, v1 := range v {
          fmt.Println(v1)
      }
  }
  ```

  

# 切片

切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

<font color=FF0000>切片是一个引用类型</font>>，它的内部结构包含`地址`、`长度`和`容量`。切片一般用于快速地操作一块数据集合。

 **`len()`**函数求长度，使用内置的**`cap()`**函数求切片的容量 

* 切片申明

  `var name []type`

  * `name` 变量名
  * `变量`类型

  ```go
  var s1 []string         // 申明string类型切片
  var s2 = []int{1, 2, 3} // 申明并初始化int类型切片
  ```

* 批量申明

  ```go
  var (
      a string
      b int
      c bool
      d float32
  )
  ```

* 切片初始化

  ```go
  s1 = []string{"a", "b", "c"}
  ```

* 使用**`make()`**函数构建切片

  `make([]type ,size , cap)`

  * type切片类型
  * size切片元素数量
  * 切片容量

  ```go
  s1 := make([]int, 3, 5)
  ```

* 切片拷贝**`copy(dest,src)`**返回拷贝元素个数

  ```go
  s1 := make([]int, 3, 5)
  s2 := make([]int, 3, 5)
  copy(s2, s1)
  fmt.Println(s2)
  
  ss5 := []int{1,2,3,4,5}
  ss6 := make([]int,len(ss5),cap(ss5))
  count := copy(ss6,ss5)
  fmt.Println(count)     // 5
  fmt.Println(len(ss5))  // 5
  fmt.Println(ss6)       // [1 2 3 4 5]
  ```

* 切片取值，`顾头不顾尾`

  `s[low: higt : max]`

  ```go
  s1 = []int{1, 2, 3, 4}
  fmt.Println(s1[:2]) // [1,2]
  fmt.Println(s1[:])  // [1,2,3,4]
  ```

* 切片添加元素

  `扩容切片name = append(name,v1,v2...)`

  ```go
  var s1 = []int{1, 2, 3, 4}
  var s2 = []int{5, 6, 7}
  
  s1 = append(s1[2:], s2[:1]...)
  fmt.Println(s1)
  
  var s3 []int
  s3 = append(s3, 1, 2, 3)
  ```

* 清空切片

  ```go
  clise = clise[0:0] // clice为切片的名字
  ```

* 删除元素

  ```go
  // 切片是引用指针类型，多次删除会在同一片内存操作
  ss3 := []string{"a","b","c","d"}
  // 删除第一个元素
  ss3 = ss3[1:]
  fmt.Println("删除第一个元素：",ss3)    //[b c d]
  // 删除最后一个元素
  ss3 = ss3[:cap(ss3)-1]
  fmt.Println("删除最后一个元素：",ss3)  // [b c]
  // 删除中间一个元素
  ss4 := []int{1,2,3,4}
  a := int(len(ss4)/2)
  ss4 = append(ss4[:a],ss4[a+1:]...)
  fmt.Println("删除中间元素：",ss4)
  ```

  

# map

* map定义

  `var name = map[string]string`

  ```go
  m1 := make(map[int]string)
  m2 := map[string]string{
      "golang": "zhang",
      "dba":    "wang",
  }
  m3 := map[int]int{}
  ```

  

* 初始化map

  `make(map[KeyType]ValueType, [cap])`

  ```go
  m1 := make(map[int]string)
  m1[1] = "zhang3"
  m1[2] = "li4"
  m1[3] = "wang5"
  m3 := map[int]int{}
  m3 = make(map[int]int)
  ```

  

* 判断某个值是否存在

  `value , ok := map[key]`

  ```go
  m2 := map[string]string{
      "golang": "zhang",
      "dba":    "wang",
  }
  
  v, ok := m2["golang"]
  if ok {
      fmt.Println(v)
  } else {
      fmt.Println("不存在")
  }
  ```

  

* map遍历

  `for range`

  ```go
  m2 := map[string]string{
      "golang": "zhang",
      "dba":    "wang",
  }
  
  for k, v := range m2 {
      fmt.Printf("key: %v\n", k)
      fmt.Printf("value: %v\n", v)
  }
  
  // 只遍历key
  for k := range m2 {
      fmt.Printf("key: %v\n", k)
  }
  ```



* 删除map键值对

  `delete(map,key)`

  ```go
  m2 := map[string]string{
      "golang": "zhang",
      "dba":    "wang",
  }
  
  delete(m2, "golang")
  fmt.Println(m2)
  ```

  

* 按照执行顺序遍历map

  `sort.Strings(keys)`对切片进行排序

  ```go
  var m3 = map[int]string{
      1: "a",
      3: "c",
      2: "b",
  }
  
  s := make([]int, 0, 3)
  
  for k := range m3 {
      fmt.Println(k)
      s = append(s, k)
  }
  
  sort.Ints(s)
  // sort.Strings(s)
  fmt.Println(s)
  
  for _, key := range s {
      fmt.Println(m3[key])
  }
  ```



* 元素为map的切片

  `var name = make([]map[type]type)`

  ```go
  var m5 = make([]map[int]string, 3)
  m5[0] = make(map[int]string)
  m5[0][1] = "zhang3"
  m5[0][2] = "li4"
  for _, v := range m5 {
      for _, v1 := range v {
          fmt.Println(v1)
      }
  }
  ```

  

* 元素为切片的map

  `var name = make(map[type][]type, 3)`

  ```go
  var m6 = make(map[int][]string, 3)
  s := make([]string, 3)
  s[0] = "beijing"
  s[2] = "shanghai"
  m6[1] = s
  fmt.Println(m6)
  ```

* 清空map

  直接新建一个map即可

